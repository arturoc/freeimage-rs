/* automatically generated by rust-bindgen */

#[link(name="freeimage")]
#[cfg_attr(target_os="linux", link(name="stdc++"))]

pub const FREEIMAGE_MAJOR_VERSION: u32 = 3;
pub const FREEIMAGE_MINOR_VERSION: u32 = 18;
pub const FREEIMAGE_RELEASE_SERIAL: u32 = 0;
pub const _WCHAR_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const FREEIMAGE_COLORORDER_BGR: u32 = 0;
pub const FREEIMAGE_COLORORDER_RGB: u32 = 1;
pub const FREEIMAGE_COLORORDER: u32 = 0;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const _INTTYPES_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const FI_RGBA_RED: u32 = 2;
pub const FI_RGBA_GREEN: u32 = 1;
pub const FI_RGBA_BLUE: u32 = 0;
pub const FI_RGBA_ALPHA: u32 = 3;
pub const FI_RGBA_RED_MASK: u32 = 16711680;
pub const FI_RGBA_GREEN_MASK: u32 = 65280;
pub const FI_RGBA_BLUE_MASK: u32 = 255;
pub const FI_RGBA_ALPHA_MASK: u32 = 4278190080;
pub const FI_RGBA_RED_SHIFT: u32 = 16;
pub const FI_RGBA_GREEN_SHIFT: u32 = 8;
pub const FI_RGBA_BLUE_SHIFT: u32 = 0;
pub const FI_RGBA_ALPHA_SHIFT: u32 = 24;
pub const FI_RGBA_RGB_MASK: u32 = 16777215;
pub const FI16_555_RED_MASK: u32 = 31744;
pub const FI16_555_GREEN_MASK: u32 = 992;
pub const FI16_555_BLUE_MASK: u32 = 31;
pub const FI16_555_RED_SHIFT: u32 = 10;
pub const FI16_555_GREEN_SHIFT: u32 = 5;
pub const FI16_555_BLUE_SHIFT: u32 = 0;
pub const FI16_565_RED_MASK: u32 = 63488;
pub const FI16_565_GREEN_MASK: u32 = 2016;
pub const FI16_565_BLUE_MASK: u32 = 31;
pub const FI16_565_RED_SHIFT: u32 = 11;
pub const FI16_565_GREEN_SHIFT: u32 = 5;
pub const FI16_565_BLUE_SHIFT: u32 = 0;
pub const FIICC_DEFAULT: u32 = 0;
pub const FIICC_COLOR_IS_CMYK: u32 = 1;
pub const FIF_LOAD_NOPIXELS: u32 = 32768;
pub const BMP_DEFAULT: u32 = 0;
pub const BMP_SAVE_RLE: u32 = 1;
pub const CUT_DEFAULT: u32 = 0;
pub const DDS_DEFAULT: u32 = 0;
pub const EXR_DEFAULT: u32 = 0;
pub const EXR_FLOAT: u32 = 1;
pub const EXR_NONE: u32 = 2;
pub const EXR_ZIP: u32 = 4;
pub const EXR_PIZ: u32 = 8;
pub const EXR_PXR24: u32 = 16;
pub const EXR_B44: u32 = 32;
pub const EXR_LC: u32 = 64;
pub const FAXG3_DEFAULT: u32 = 0;
pub const GIF_DEFAULT: u32 = 0;
pub const GIF_LOAD256: u32 = 1;
pub const GIF_PLAYBACK: u32 = 2;
pub const HDR_DEFAULT: u32 = 0;
pub const ICO_DEFAULT: u32 = 0;
pub const ICO_MAKEALPHA: u32 = 1;
pub const IFF_DEFAULT: u32 = 0;
pub const J2K_DEFAULT: u32 = 0;
pub const JP2_DEFAULT: u32 = 0;
pub const JPEG_DEFAULT: u32 = 0;
pub const JPEG_FAST: u32 = 1;
pub const JPEG_ACCURATE: u32 = 2;
pub const JPEG_CMYK: u32 = 4;
pub const JPEG_EXIFROTATE: u32 = 8;
pub const JPEG_GREYSCALE: u32 = 16;
pub const JPEG_QUALITYSUPERB: u32 = 128;
pub const JPEG_QUALITYGOOD: u32 = 256;
pub const JPEG_QUALITYNORMAL: u32 = 512;
pub const JPEG_QUALITYAVERAGE: u32 = 1024;
pub const JPEG_QUALITYBAD: u32 = 2048;
pub const JPEG_PROGRESSIVE: u32 = 8192;
pub const JPEG_SUBSAMPLING_411: u32 = 4096;
pub const JPEG_SUBSAMPLING_420: u32 = 16384;
pub const JPEG_SUBSAMPLING_422: u32 = 32768;
pub const JPEG_SUBSAMPLING_444: u32 = 65536;
pub const JPEG_OPTIMIZE: u32 = 131072;
pub const JPEG_BASELINE: u32 = 262144;
pub const KOALA_DEFAULT: u32 = 0;
pub const LBM_DEFAULT: u32 = 0;
pub const MNG_DEFAULT: u32 = 0;
pub const PCD_DEFAULT: u32 = 0;
pub const PCD_BASE: u32 = 1;
pub const PCD_BASEDIV4: u32 = 2;
pub const PCD_BASEDIV16: u32 = 3;
pub const PCX_DEFAULT: u32 = 0;
pub const PFM_DEFAULT: u32 = 0;
pub const PICT_DEFAULT: u32 = 0;
pub const PNG_DEFAULT: u32 = 0;
pub const PNG_IGNOREGAMMA: u32 = 1;
pub const PNG_Z_BEST_SPEED: u32 = 1;
pub const PNG_Z_DEFAULT_COMPRESSION: u32 = 6;
pub const PNG_Z_BEST_COMPRESSION: u32 = 9;
pub const PNG_Z_NO_COMPRESSION: u32 = 256;
pub const PNG_INTERLACED: u32 = 512;
pub const PNM_DEFAULT: u32 = 0;
pub const PNM_SAVE_RAW: u32 = 0;
pub const PNM_SAVE_ASCII: u32 = 1;
pub const PSD_DEFAULT: u32 = 0;
pub const PSD_CMYK: u32 = 1;
pub const PSD_LAB: u32 = 2;
pub const PSD_NONE: u32 = 256;
pub const PSD_RLE: u32 = 512;
pub const PSD_PSB: u32 = 8192;
pub const RAS_DEFAULT: u32 = 0;
pub const RAW_DEFAULT: u32 = 0;
pub const RAW_PREVIEW: u32 = 1;
pub const RAW_DISPLAY: u32 = 2;
pub const RAW_HALFSIZE: u32 = 4;
pub const RAW_UNPROCESSED: u32 = 8;
pub const SGI_DEFAULT: u32 = 0;
pub const TARGA_DEFAULT: u32 = 0;
pub const TARGA_LOAD_RGB888: u32 = 1;
pub const TARGA_SAVE_RLE: u32 = 2;
pub const TIFF_DEFAULT: u32 = 0;
pub const TIFF_CMYK: u32 = 1;
pub const TIFF_PACKBITS: u32 = 256;
pub const TIFF_DEFLATE: u32 = 512;
pub const TIFF_ADOBE_DEFLATE: u32 = 1024;
pub const TIFF_NONE: u32 = 2048;
pub const TIFF_CCITTFAX3: u32 = 4096;
pub const TIFF_CCITTFAX4: u32 = 8192;
pub const TIFF_LZW: u32 = 16384;
pub const TIFF_JPEG: u32 = 32768;
pub const TIFF_LOGLUV: u32 = 65536;
pub const WBMP_DEFAULT: u32 = 0;
pub const XBM_DEFAULT: u32 = 0;
pub const XPM_DEFAULT: u32 = 0;
pub const WEBP_DEFAULT: u32 = 0;
pub const WEBP_LOSSLESS: u32 = 256;
pub const JXR_DEFAULT: u32 = 0;
pub const JXR_LOSSLESS: u32 = 100;
pub const JXR_PROGRESSIVE: u32 = 8192;
pub const FI_COLOR_IS_RGB_COLOR: u32 = 0;
pub const FI_COLOR_IS_RGBA_COLOR: u32 = 1;
pub const FI_COLOR_FIND_EQUAL_COLOR: u32 = 2;
pub const FI_COLOR_ALPHA_IS_INDEX: u32 = 4;
pub const FI_COLOR_PALETTE_SEARCH_MASK: u32 = 6;
pub const FI_RESCALE_DEFAULT: u32 = 0;
pub const FI_RESCALE_TRUE_COLOR: u32 = 1;
pub const FI_RESCALE_OMIT_METADATA: u32 = 2;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcscoll_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: size_t,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(
        __wcs: *const ::std::os::raw::c_int,
        __wc: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn wmemchr(
        __s: *const ::std::os::raw::c_int,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcmp(
        __s1: *const ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemmove(
        __s1: *mut ::std::os::raw::c_int,
        __s2: *const ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __p: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t, __ps: *mut mbstate_t)
        -> size_t;
}
extern "C" {
    pub fn __mbrlen(
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: size_t, __ps: *mut mbstate_t) -> size_t;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const ::std::os::raw::c_char,
        __nmc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut ::std::os::raw::c_char,
        __src: *mut *const wchar_t,
        __nwc: size_t,
        __len: size_t,
        __ps: *mut mbstate_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut size_t) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: size_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(
        __ws: *mut wchar_t,
        __n: ::std::os::raw::c_int,
        __stream: *mut __FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: size_t,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIBITMAP {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FIBITMAP() {
    assert_eq!(
        ::std::mem::size_of::<FIBITMAP>(),
        8usize,
        concat!("Size of: ", stringify!(FIBITMAP))
    );
    assert_eq!(
        ::std::mem::align_of::<FIBITMAP>(),
        8usize,
        concat!("Alignment of ", stringify!(FIBITMAP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIBITMAP>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIBITMAP),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIMULTIBITMAP {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FIMULTIBITMAP() {
    assert_eq!(
        ::std::mem::size_of::<FIMULTIBITMAP>(),
        8usize,
        concat!("Size of: ", stringify!(FIMULTIBITMAP))
    );
    assert_eq!(
        ::std::mem::align_of::<FIMULTIBITMAP>(),
        8usize,
        concat!("Alignment of ", stringify!(FIMULTIBITMAP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIMULTIBITMAP>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIMULTIBITMAP),
            "::",
            stringify!(data)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type BOOL = i32;
pub type BYTE = u8;
pub type WORD = u16;
pub type DWORD = u32;
pub type LONG = i32;
pub type INT64 = i64;
pub type UINT64 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRGBQUAD {
    pub rgbBlue: BYTE,
    pub rgbGreen: BYTE,
    pub rgbRed: BYTE,
    pub rgbReserved: BYTE,
}
#[test]
fn bindgen_test_layout_tagRGBQUAD() {
    assert_eq!(
        ::std::mem::size_of::<tagRGBQUAD>(),
        4usize,
        concat!("Size of: ", stringify!(tagRGBQUAD))
    );
    assert_eq!(
        ::std::mem::align_of::<tagRGBQUAD>(),
        1usize,
        concat!("Alignment of ", stringify!(tagRGBQUAD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBQUAD>())).rgbBlue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBQUAD),
            "::",
            stringify!(rgbBlue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBQUAD>())).rgbGreen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBQUAD),
            "::",
            stringify!(rgbGreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBQUAD>())).rgbRed as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBQUAD),
            "::",
            stringify!(rgbRed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBQUAD>())).rgbReserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBQUAD),
            "::",
            stringify!(rgbReserved)
        )
    );
}
pub type RGBQUAD = tagRGBQUAD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagRGBTRIPLE {
    pub rgbtBlue: BYTE,
    pub rgbtGreen: BYTE,
    pub rgbtRed: BYTE,
}
#[test]
fn bindgen_test_layout_tagRGBTRIPLE() {
    assert_eq!(
        ::std::mem::size_of::<tagRGBTRIPLE>(),
        3usize,
        concat!("Size of: ", stringify!(tagRGBTRIPLE))
    );
    assert_eq!(
        ::std::mem::align_of::<tagRGBTRIPLE>(),
        1usize,
        concat!("Alignment of ", stringify!(tagRGBTRIPLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBTRIPLE>())).rgbtBlue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBTRIPLE),
            "::",
            stringify!(rgbtBlue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBTRIPLE>())).rgbtGreen as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBTRIPLE),
            "::",
            stringify!(rgbtGreen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagRGBTRIPLE>())).rgbtRed as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagRGBTRIPLE),
            "::",
            stringify!(rgbtRed)
        )
    );
}
pub type RGBTRIPLE = tagRGBTRIPLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPINFOHEADER {
    pub biSize: DWORD,
    pub biWidth: LONG,
    pub biHeight: LONG,
    pub biPlanes: WORD,
    pub biBitCount: WORD,
    pub biCompression: DWORD,
    pub biSizeImage: DWORD,
    pub biXPelsPerMeter: LONG,
    pub biYPelsPerMeter: LONG,
    pub biClrUsed: DWORD,
    pub biClrImportant: DWORD,
}
#[test]
fn bindgen_test_layout_tagBITMAPINFOHEADER() {
    assert_eq!(
        ::std::mem::size_of::<tagBITMAPINFOHEADER>(),
        40usize,
        concat!("Size of: ", stringify!(tagBITMAPINFOHEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<tagBITMAPINFOHEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(tagBITMAPINFOHEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biWidth as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biHeight as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biPlanes as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biPlanes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biBitCount as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biBitCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biCompression as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biCompression)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biSizeImage as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biSizeImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biXPelsPerMeter as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biXPelsPerMeter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biYPelsPerMeter as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biYPelsPerMeter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biClrUsed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biClrUsed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<tagBITMAPINFOHEADER>())).biClrImportant as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFOHEADER),
            "::",
            stringify!(biClrImportant)
        )
    );
}
pub type BITMAPINFOHEADER = tagBITMAPINFOHEADER;
pub type PBITMAPINFOHEADER = *mut tagBITMAPINFOHEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBITMAPINFO {
    pub bmiHeader: BITMAPINFOHEADER,
    pub bmiColors: [RGBQUAD; 1usize],
}
#[test]
fn bindgen_test_layout_tagBITMAPINFO() {
    assert_eq!(
        ::std::mem::size_of::<tagBITMAPINFO>(),
        44usize,
        concat!("Size of: ", stringify!(tagBITMAPINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<tagBITMAPINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(tagBITMAPINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFO>())).bmiHeader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFO),
            "::",
            stringify!(bmiHeader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagBITMAPINFO>())).bmiColors as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tagBITMAPINFO),
            "::",
            stringify!(bmiColors)
        )
    );
}
pub type BITMAPINFO = tagBITMAPINFO;
pub type PBITMAPINFO = *mut tagBITMAPINFO;
#[doc = " 48-bit RGB"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagFIRGB16 {
    pub red: WORD,
    pub green: WORD,
    pub blue: WORD,
}
#[test]
fn bindgen_test_layout_tagFIRGB16() {
    assert_eq!(
        ::std::mem::size_of::<tagFIRGB16>(),
        6usize,
        concat!("Size of: ", stringify!(tagFIRGB16))
    );
    assert_eq!(
        ::std::mem::align_of::<tagFIRGB16>(),
        1usize,
        concat!("Alignment of ", stringify!(tagFIRGB16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGB16>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGB16),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGB16>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGB16),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGB16>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGB16),
            "::",
            stringify!(blue)
        )
    );
}
#[doc = " 48-bit RGB"]
pub type FIRGB16 = tagFIRGB16;
#[doc = " 64-bit RGBA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagFIRGBA16 {
    pub red: WORD,
    pub green: WORD,
    pub blue: WORD,
    pub alpha: WORD,
}
#[test]
fn bindgen_test_layout_tagFIRGBA16() {
    assert_eq!(
        ::std::mem::size_of::<tagFIRGBA16>(),
        8usize,
        concat!("Size of: ", stringify!(tagFIRGBA16))
    );
    assert_eq!(
        ::std::mem::align_of::<tagFIRGBA16>(),
        1usize,
        concat!("Alignment of ", stringify!(tagFIRGBA16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBA16>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBA16),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBA16>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBA16),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBA16>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBA16),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBA16>())).alpha as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBA16),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " 64-bit RGBA"]
pub type FIRGBA16 = tagFIRGBA16;
#[doc = " 96-bit RGB Float"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagFIRGBF {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
}
#[test]
fn bindgen_test_layout_tagFIRGBF() {
    assert_eq!(
        ::std::mem::size_of::<tagFIRGBF>(),
        12usize,
        concat!("Size of: ", stringify!(tagFIRGBF))
    );
    assert_eq!(
        ::std::mem::align_of::<tagFIRGBF>(),
        1usize,
        concat!("Alignment of ", stringify!(tagFIRGBF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBF>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBF),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBF>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBF),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBF>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBF),
            "::",
            stringify!(blue)
        )
    );
}
#[doc = " 96-bit RGB Float"]
pub type FIRGBF = tagFIRGBF;
#[doc = " 128-bit RGBA Float"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagFIRGBAF {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout_tagFIRGBAF() {
    assert_eq!(
        ::std::mem::size_of::<tagFIRGBAF>(),
        16usize,
        concat!("Size of: ", stringify!(tagFIRGBAF))
    );
    assert_eq!(
        ::std::mem::align_of::<tagFIRGBAF>(),
        1usize,
        concat!("Alignment of ", stringify!(tagFIRGBAF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBAF>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBAF),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBAF>())).green as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBAF),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBAF>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBAF),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFIRGBAF>())).alpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFIRGBAF),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " 128-bit RGBA Float"]
pub type FIRGBAF = tagFIRGBAF;
#[doc = " Data structure for COMPLEX type (complex number)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagFICOMPLEX {
    #[doc = " real part"]
    pub r: f64,
    #[doc = " imaginary part"]
    pub i: f64,
}
#[test]
fn bindgen_test_layout_tagFICOMPLEX() {
    assert_eq!(
        ::std::mem::size_of::<tagFICOMPLEX>(),
        16usize,
        concat!("Size of: ", stringify!(tagFICOMPLEX))
    );
    assert_eq!(
        ::std::mem::align_of::<tagFICOMPLEX>(),
        1usize,
        concat!("Alignment of ", stringify!(tagFICOMPLEX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFICOMPLEX>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFICOMPLEX),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagFICOMPLEX>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagFICOMPLEX),
            "::",
            stringify!(i)
        )
    );
}
#[doc = " Data structure for COMPLEX type (complex number)"]
pub type FICOMPLEX = tagFICOMPLEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIICCPROFILE {
    pub flags: WORD,
    #[doc = "! info flag"]
    pub size: DWORD,
    #[doc = "! profile's size measured in bytes"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FIICCPROFILE() {
    assert_eq!(
        ::std::mem::size_of::<FIICCPROFILE>(),
        16usize,
        concat!("Size of: ", stringify!(FIICCPROFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<FIICCPROFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(FIICCPROFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIICCPROFILE>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIICCPROFILE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIICCPROFILE>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FIICCPROFILE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIICCPROFILE>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FIICCPROFILE),
            "::",
            stringify!(data)
        )
    );
}

pub const FREE_IMAGE_FORMAT_FIF_UNKNOWN: FREE_IMAGE_FORMAT = -1;
pub const FREE_IMAGE_FORMAT_FIF_BMP: FREE_IMAGE_FORMAT = 0;
pub const FREE_IMAGE_FORMAT_FIF_ICO: FREE_IMAGE_FORMAT = 1;
pub const FREE_IMAGE_FORMAT_FIF_JPEG: FREE_IMAGE_FORMAT = 2;
pub const FREE_IMAGE_FORMAT_FIF_JNG: FREE_IMAGE_FORMAT = 3;
pub const FREE_IMAGE_FORMAT_FIF_KOALA: FREE_IMAGE_FORMAT = 4;
pub const FREE_IMAGE_FORMAT_FIF_LBM: FREE_IMAGE_FORMAT = 5;
pub const FREE_IMAGE_FORMAT_FIF_IFF: FREE_IMAGE_FORMAT = 5;
pub const FREE_IMAGE_FORMAT_FIF_MNG: FREE_IMAGE_FORMAT = 6;
pub const FREE_IMAGE_FORMAT_FIF_PBM: FREE_IMAGE_FORMAT = 7;
pub const FREE_IMAGE_FORMAT_FIF_PBMRAW: FREE_IMAGE_FORMAT = 8;
pub const FREE_IMAGE_FORMAT_FIF_PCD: FREE_IMAGE_FORMAT = 9;
pub const FREE_IMAGE_FORMAT_FIF_PCX: FREE_IMAGE_FORMAT = 10;
pub const FREE_IMAGE_FORMAT_FIF_PGM: FREE_IMAGE_FORMAT = 11;
pub const FREE_IMAGE_FORMAT_FIF_PGMRAW: FREE_IMAGE_FORMAT = 12;
pub const FREE_IMAGE_FORMAT_FIF_PNG: FREE_IMAGE_FORMAT = 13;
pub const FREE_IMAGE_FORMAT_FIF_PPM: FREE_IMAGE_FORMAT = 14;
pub const FREE_IMAGE_FORMAT_FIF_PPMRAW: FREE_IMAGE_FORMAT = 15;
pub const FREE_IMAGE_FORMAT_FIF_RAS: FREE_IMAGE_FORMAT = 16;
pub const FREE_IMAGE_FORMAT_FIF_TARGA: FREE_IMAGE_FORMAT = 17;
pub const FREE_IMAGE_FORMAT_FIF_TIFF: FREE_IMAGE_FORMAT = 18;
pub const FREE_IMAGE_FORMAT_FIF_WBMP: FREE_IMAGE_FORMAT = 19;
pub const FREE_IMAGE_FORMAT_FIF_PSD: FREE_IMAGE_FORMAT = 20;
pub const FREE_IMAGE_FORMAT_FIF_CUT: FREE_IMAGE_FORMAT = 21;
pub const FREE_IMAGE_FORMAT_FIF_XBM: FREE_IMAGE_FORMAT = 22;
pub const FREE_IMAGE_FORMAT_FIF_XPM: FREE_IMAGE_FORMAT = 23;
pub const FREE_IMAGE_FORMAT_FIF_DDS: FREE_IMAGE_FORMAT = 24;
pub const FREE_IMAGE_FORMAT_FIF_GIF: FREE_IMAGE_FORMAT = 25;
pub const FREE_IMAGE_FORMAT_FIF_HDR: FREE_IMAGE_FORMAT = 26;
pub const FREE_IMAGE_FORMAT_FIF_FAXG3: FREE_IMAGE_FORMAT = 27;
pub const FREE_IMAGE_FORMAT_FIF_SGI: FREE_IMAGE_FORMAT = 28;
pub const FREE_IMAGE_FORMAT_FIF_EXR: FREE_IMAGE_FORMAT = 29;
pub const FREE_IMAGE_FORMAT_FIF_J2K: FREE_IMAGE_FORMAT = 30;
pub const FREE_IMAGE_FORMAT_FIF_JP2: FREE_IMAGE_FORMAT = 31;
pub const FREE_IMAGE_FORMAT_FIF_PFM: FREE_IMAGE_FORMAT = 32;
pub const FREE_IMAGE_FORMAT_FIF_PICT: FREE_IMAGE_FORMAT = 33;
pub const FREE_IMAGE_FORMAT_FIF_RAW: FREE_IMAGE_FORMAT = 34;
pub const FREE_IMAGE_FORMAT_FIF_WEBP: FREE_IMAGE_FORMAT = 35;
pub const FREE_IMAGE_FORMAT_FIF_JXR: FREE_IMAGE_FORMAT = 36;
#[doc = " I/O image format identifiers."]
pub type FREE_IMAGE_FORMAT = i32;
pub const FREE_IMAGE_TYPE_FIT_UNKNOWN: FREE_IMAGE_TYPE = 0;
#[doc = "! unknown type"]
pub const FREE_IMAGE_TYPE_FIT_BITMAP: FREE_IMAGE_TYPE = 1;
#[doc = "! standard image\t\t\t: 1-, 4-, 8-, 16-, 24-, 32-bit"]
pub const FREE_IMAGE_TYPE_FIT_UINT16: FREE_IMAGE_TYPE = 2;
#[doc = "! array of unsigned short\t: unsigned 16-bit"]
pub const FREE_IMAGE_TYPE_FIT_INT16: FREE_IMAGE_TYPE = 3;
#[doc = "! array of short\t\t\t: signed 16-bit"]
pub const FREE_IMAGE_TYPE_FIT_UINT32: FREE_IMAGE_TYPE = 4;
#[doc = "! array of unsigned long\t: unsigned 32-bit"]
pub const FREE_IMAGE_TYPE_FIT_INT32: FREE_IMAGE_TYPE = 5;
#[doc = "! array of long\t\t\t: signed 32-bit"]
pub const FREE_IMAGE_TYPE_FIT_FLOAT: FREE_IMAGE_TYPE = 6;
#[doc = "! array of float\t\t\t: 32-bit IEEE floating point"]
pub const FREE_IMAGE_TYPE_FIT_DOUBLE: FREE_IMAGE_TYPE = 7;
#[doc = "! array of double\t\t\t: 64-bit IEEE floating point"]
pub const FREE_IMAGE_TYPE_FIT_COMPLEX: FREE_IMAGE_TYPE = 8;
#[doc = "! array of FICOMPLEX\t\t: 2 x 64-bit IEEE floating point"]
pub const FREE_IMAGE_TYPE_FIT_RGB16: FREE_IMAGE_TYPE = 9;
#[doc = "! 48-bit RGB image\t\t\t: 3 x 16-bit"]
pub const FREE_IMAGE_TYPE_FIT_RGBA16: FREE_IMAGE_TYPE = 10;
#[doc = "! 64-bit RGBA image\t\t: 4 x 16-bit"]
pub const FREE_IMAGE_TYPE_FIT_RGBF: FREE_IMAGE_TYPE = 11;
#[doc = "! 96-bit RGB float image\t: 3 x 32-bit IEEE floating point"]
pub const FREE_IMAGE_TYPE_FIT_RGBAF: FREE_IMAGE_TYPE = 12;
#[doc = " Image type used in FreeImage."]
pub type FREE_IMAGE_TYPE = u32;
pub const FREE_IMAGE_COLOR_TYPE_FIC_MINISWHITE: FREE_IMAGE_COLOR_TYPE = 0;
#[doc = "! min value is white"]
pub const FREE_IMAGE_COLOR_TYPE_FIC_MINISBLACK: FREE_IMAGE_COLOR_TYPE = 1;
#[doc = "! min value is black"]
pub const FREE_IMAGE_COLOR_TYPE_FIC_RGB: FREE_IMAGE_COLOR_TYPE = 2;
#[doc = "! RGB color model"]
pub const FREE_IMAGE_COLOR_TYPE_FIC_PALETTE: FREE_IMAGE_COLOR_TYPE = 3;
#[doc = "! color map indexed"]
pub const FREE_IMAGE_COLOR_TYPE_FIC_RGBALPHA: FREE_IMAGE_COLOR_TYPE = 4;
#[doc = "! RGB color model with alpha channel"]
pub const FREE_IMAGE_COLOR_TYPE_FIC_CMYK: FREE_IMAGE_COLOR_TYPE = 5;
#[doc = " Image color type used in FreeImage."]
pub type FREE_IMAGE_COLOR_TYPE = u32;
pub type FREE_IMAGE_QUANTIZE = ::std::os::raw::c_int;
pub const FREE_IMAGE_QUANTIZE_FIQ_WUQUANT: FREE_IMAGE_QUANTIZE = 0;
#[doc = "! Xiaolin Wu color quantization algorithm"]
pub const FREE_IMAGE_QUANTIZE_FIQ_NNQUANT: FREE_IMAGE_QUANTIZE = 1;
#[doc = "! NeuQuant neural-net quantization algorithm by Anthony Dekker"]
pub const FREE_IMAGE_QUANTIZE_FIQ_LFPQUANT: FREE_IMAGE_QUANTIZE = 2;
#[doc = " Color quantization algorithms."]
pub type FREE_IMAGE_DITHER = ::std::os::raw::c_int;
pub const FREE_IMAGE_DITHER_FID_FS: FREE_IMAGE_DITHER = 0;
#[doc = "! Floyd & Steinberg error diffusion"]
pub const FREE_IMAGE_DITHER_FID_BAYER4x4: FREE_IMAGE_DITHER = 1;
#[doc = "! Bayer ordered dispersed dot dithering (order 2 dithering matrix)"]
pub const FREE_IMAGE_DITHER_FID_BAYER8x8: FREE_IMAGE_DITHER = 2;
#[doc = "! Bayer ordered dispersed dot dithering (order 3 dithering matrix)"]
pub const FREE_IMAGE_DITHER_FID_CLUSTER6x6: FREE_IMAGE_DITHER = 3;
#[doc = "! Ordered clustered dot dithering (order 3 - 6x6 matrix)"]
pub const FREE_IMAGE_DITHER_FID_CLUSTER8x8: FREE_IMAGE_DITHER = 4;
#[doc = "! Ordered clustered dot dithering (order 4 - 8x8 matrix)"]
pub const FREE_IMAGE_DITHER_FID_CLUSTER16x16: FREE_IMAGE_DITHER = 5;
#[doc = "! Ordered clustered dot dithering (order 8 - 16x16 matrix)"]
pub const FREE_IMAGE_DITHER_FID_BAYER16x16: FREE_IMAGE_DITHER = 6;
#[doc = " Dithering algorithms."]
pub type FREE_IMAGE_TMO = ::std::os::raw::c_int;
pub const FREE_IMAGE_TMO_FITMO_DRAGO03: FREE_IMAGE_TMO = 0;
#[doc = "! Adaptive logarithmic mapping (F. Drago, 2003)"]
pub const FREE_IMAGE_TMO_FITMO_REINHARD05: FREE_IMAGE_TMO = 1;
#[doc = "! Dynamic range reduction inspired by photoreceptor physiology (E. Reinhard, 2005)"]
pub const FREE_IMAGE_TMO_FITMO_FATTAL02: FREE_IMAGE_TMO = 2;
#[doc = " Tone mapping operators."]
pub type FREE_IMAGE_FILTER = ::std::os::raw::c_int;
pub const FREE_IMAGE_FILTER_FILTER_BOX: FREE_IMAGE_FILTER = 0;
#[doc = "! Box, pulse, Fourier window, 1st order (constant) b-spline"]
pub const FREE_IMAGE_FILTER_FILTER_BICUBIC: FREE_IMAGE_FILTER = 1;
#[doc = "! Mitchell & Netravali's two-param cubic filter"]
pub const FREE_IMAGE_FILTER_FILTER_BILINEAR: FREE_IMAGE_FILTER = 2;
#[doc = "! Bilinear filter"]
pub const FREE_IMAGE_FILTER_FILTER_BSPLINE: FREE_IMAGE_FILTER = 3;
#[doc = "! 4th order (cubic) b-spline"]
pub const FREE_IMAGE_FILTER_FILTER_CATMULLROM: FREE_IMAGE_FILTER = 4;
#[doc = "! Catmull-Rom spline, Overhauser spline"]
pub const FREE_IMAGE_FILTER_FILTER_LANCZOS3: FREE_IMAGE_FILTER = 5;
#[doc = " Upsampling / downsampling filters."]
pub type FREE_IMAGE_COLOR_CHANNEL = ::std::os::raw::c_int;
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_RGB: FREE_IMAGE_COLOR_CHANNEL = 0;
#[doc = "! Use red, green and blue channels"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_RED: FREE_IMAGE_COLOR_CHANNEL = 1;
#[doc = "! Use red channel"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_GREEN: FREE_IMAGE_COLOR_CHANNEL = 2;
#[doc = "! Use green channel"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_BLUE: FREE_IMAGE_COLOR_CHANNEL = 3;
#[doc = "! Use blue channel"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_ALPHA: FREE_IMAGE_COLOR_CHANNEL = 4;
#[doc = "! Use alpha channel"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_BLACK: FREE_IMAGE_COLOR_CHANNEL = 5;
#[doc = "! Use black channel"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_REAL: FREE_IMAGE_COLOR_CHANNEL = 6;
#[doc = "! Complex images: use real part"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_IMAG: FREE_IMAGE_COLOR_CHANNEL = 7;
#[doc = "! Complex images: use imaginary part"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_MAG: FREE_IMAGE_COLOR_CHANNEL = 8;
#[doc = "! Complex images: use magnitude"]
pub const FREE_IMAGE_COLOR_CHANNEL_FICC_PHASE: FREE_IMAGE_COLOR_CHANNEL = 9;
#[doc = " Color channels."]
pub type FREE_IMAGE_MDTYPE = ::std::os::raw::c_int;
pub const FREE_IMAGE_MDTYPE_FIDT_NOTYPE: FREE_IMAGE_MDTYPE = 0;
#[doc = "! placeholder"]
pub const FREE_IMAGE_MDTYPE_FIDT_BYTE: FREE_IMAGE_MDTYPE = 1;
#[doc = "! 8-bit unsigned integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_ASCII: FREE_IMAGE_MDTYPE = 2;
#[doc = "! 8-bit bytes w/ last byte null"]
pub const FREE_IMAGE_MDTYPE_FIDT_SHORT: FREE_IMAGE_MDTYPE = 3;
#[doc = "! 16-bit unsigned integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_LONG: FREE_IMAGE_MDTYPE = 4;
#[doc = "! 32-bit unsigned integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_RATIONAL: FREE_IMAGE_MDTYPE = 5;
#[doc = "! 64-bit unsigned fraction"]
pub const FREE_IMAGE_MDTYPE_FIDT_SBYTE: FREE_IMAGE_MDTYPE = 6;
#[doc = "! 8-bit signed integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_UNDEFINED: FREE_IMAGE_MDTYPE = 7;
#[doc = "! 8-bit untyped data"]
pub const FREE_IMAGE_MDTYPE_FIDT_SSHORT: FREE_IMAGE_MDTYPE = 8;
#[doc = "! 16-bit signed integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_SLONG: FREE_IMAGE_MDTYPE = 9;
#[doc = "! 32-bit signed integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_SRATIONAL: FREE_IMAGE_MDTYPE = 10;
#[doc = "! 64-bit signed fraction"]
pub const FREE_IMAGE_MDTYPE_FIDT_FLOAT: FREE_IMAGE_MDTYPE = 11;
#[doc = "! 32-bit IEEE floating point"]
pub const FREE_IMAGE_MDTYPE_FIDT_DOUBLE: FREE_IMAGE_MDTYPE = 12;
#[doc = "! 64-bit IEEE floating point"]
pub const FREE_IMAGE_MDTYPE_FIDT_IFD: FREE_IMAGE_MDTYPE = 13;
#[doc = "! 32-bit unsigned integer (offset)"]
pub const FREE_IMAGE_MDTYPE_FIDT_PALETTE: FREE_IMAGE_MDTYPE = 14;
#[doc = "! 32-bit RGBQUAD"]
pub const FREE_IMAGE_MDTYPE_FIDT_LONG8: FREE_IMAGE_MDTYPE = 16;
#[doc = "! 64-bit unsigned integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_SLONG8: FREE_IMAGE_MDTYPE = 17;
#[doc = "! 64-bit signed integer"]
pub const FREE_IMAGE_MDTYPE_FIDT_IFD8: FREE_IMAGE_MDTYPE = 18;
pub type FREE_IMAGE_MDMODEL = ::std::os::raw::c_int;
pub const FREE_IMAGE_MDMODEL_FIMD_NODATA: FREE_IMAGE_MDMODEL = -1;
pub const FREE_IMAGE_MDMODEL_FIMD_COMMENTS: FREE_IMAGE_MDMODEL = 0;
#[doc = "! single comment or keywords"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_MAIN: FREE_IMAGE_MDMODEL = 1;
#[doc = "! Exif-TIFF metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_EXIF: FREE_IMAGE_MDMODEL = 2;
#[doc = "! Exif-specific metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_GPS: FREE_IMAGE_MDMODEL = 3;
#[doc = "! Exif GPS metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_MAKERNOTE: FREE_IMAGE_MDMODEL = 4;
#[doc = "! Exif maker note metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_INTEROP: FREE_IMAGE_MDMODEL = 5;
#[doc = "! Exif interoperability metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_IPTC: FREE_IMAGE_MDMODEL = 6;
#[doc = "! IPTC/NAA metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_XMP: FREE_IMAGE_MDMODEL = 7;
#[doc = "! Abobe XMP metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_GEOTIFF: FREE_IMAGE_MDMODEL = 8;
#[doc = "! GeoTIFF metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_ANIMATION: FREE_IMAGE_MDMODEL = 9;
#[doc = "! Animation metadata"]
pub const FREE_IMAGE_MDMODEL_FIMD_CUSTOM: FREE_IMAGE_MDMODEL = 10;
#[doc = "! Used to attach other metadata types to a dib"]
pub const FREE_IMAGE_MDMODEL_FIMD_EXIF_RAW: FREE_IMAGE_MDMODEL = 11;
#[doc = "Handle to a metadata model"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIMETADATA {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FIMETADATA() {
    assert_eq!(
        ::std::mem::size_of::<FIMETADATA>(),
        8usize,
        concat!("Size of: ", stringify!(FIMETADATA))
    );
    assert_eq!(
        ::std::mem::align_of::<FIMETADATA>(),
        8usize,
        concat!("Alignment of ", stringify!(FIMETADATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIMETADATA>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIMETADATA),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "Handle to a FreeImage tag"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FITAG {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FITAG() {
    assert_eq!(
        ::std::mem::size_of::<FITAG>(),
        8usize,
        concat!("Size of: ", stringify!(FITAG))
    );
    assert_eq!(
        ::std::mem::align_of::<FITAG>(),
        8usize,
        concat!("Alignment of ", stringify!(FITAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FITAG>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FITAG),
            "::",
            stringify!(data)
        )
    );
}
pub type fi_handle = *mut ::std::os::raw::c_void;
pub type FI_ReadProc = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        handle: fi_handle,
    ) -> ::std::os::raw::c_uint,
>;
pub type FI_WriteProc = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        handle: fi_handle,
    ) -> ::std::os::raw::c_uint,
>;
pub type FI_SeekProc = ::std::option::Option<
    unsafe extern "C" fn(
        handle: fi_handle,
        offset: ::std::os::raw::c_long,
        origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type FI_TellProc =
    ::std::option::Option<unsafe extern "C" fn(handle: fi_handle) -> ::std::os::raw::c_long>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FreeImageIO {
    pub read_proc: FI_ReadProc,
    #[doc = "! pointer to the function used to read data"]
    pub write_proc: FI_WriteProc,
    #[doc = "! pointer to the function used to write data"]
    pub seek_proc: FI_SeekProc,
    #[doc = "! pointer to the function used to seek"]
    pub tell_proc: FI_TellProc,
}
#[test]
fn bindgen_test_layout_FreeImageIO() {
    assert_eq!(
        ::std::mem::size_of::<FreeImageIO>(),
        32usize,
        concat!("Size of: ", stringify!(FreeImageIO))
    );
    assert_eq!(
        ::std::mem::align_of::<FreeImageIO>(),
        1usize,
        concat!("Alignment of ", stringify!(FreeImageIO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FreeImageIO>())).read_proc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FreeImageIO),
            "::",
            stringify!(read_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FreeImageIO>())).write_proc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FreeImageIO),
            "::",
            stringify!(write_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FreeImageIO>())).seek_proc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FreeImageIO),
            "::",
            stringify!(seek_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FreeImageIO>())).tell_proc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FreeImageIO),
            "::",
            stringify!(tell_proc)
        )
    );
}
#[doc = "Handle to a memory I/O stream"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIMEMORY {
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FIMEMORY() {
    assert_eq!(
        ::std::mem::size_of::<FIMEMORY>(),
        8usize,
        concat!("Size of: ", stringify!(FIMEMORY))
    );
    assert_eq!(
        ::std::mem::align_of::<FIMEMORY>(),
        8usize,
        concat!("Alignment of ", stringify!(FIMEMORY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FIMEMORY>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FIMEMORY),
            "::",
            stringify!(data)
        )
    );
}
pub type FI_FormatProc =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type FI_DescriptionProc =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type FI_ExtensionListProc =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type FI_RegExprProc =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type FI_OpenProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        handle: fi_handle,
        read: BOOL,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type FI_CloseProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        handle: fi_handle,
        data: *mut ::std::os::raw::c_void,
    ),
>;
pub type FI_PageCountProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        handle: fi_handle,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type FI_PageCapabilityProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        handle: fi_handle,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type FI_LoadProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        handle: fi_handle,
        page: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut FIBITMAP,
>;
pub type FI_SaveProc = ::std::option::Option<
    unsafe extern "C" fn(
        io: *mut FreeImageIO,
        dib: *mut FIBITMAP,
        handle: fi_handle,
        page: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type FI_ValidateProc =
    ::std::option::Option<unsafe extern "C" fn(io: *mut FreeImageIO, handle: fi_handle) -> BOOL>;
pub type FI_MimeProc =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type FI_SupportsExportBPPProc =
    ::std::option::Option<unsafe extern "C" fn(bpp: ::std::os::raw::c_int) -> BOOL>;
pub type FI_SupportsExportTypeProc =
    ::std::option::Option<unsafe extern "C" fn(type_: FREE_IMAGE_TYPE) -> BOOL>;
pub type FI_SupportsICCProfilesProc = ::std::option::Option<unsafe extern "C" fn() -> BOOL>;
pub type FI_SupportsNoPixelsProc = ::std::option::Option<unsafe extern "C" fn() -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Plugin {
    pub format_proc: FI_FormatProc,
    pub description_proc: FI_DescriptionProc,
    pub extension_proc: FI_ExtensionListProc,
    pub regexpr_proc: FI_RegExprProc,
    pub open_proc: FI_OpenProc,
    pub close_proc: FI_CloseProc,
    pub pagecount_proc: FI_PageCountProc,
    pub pagecapability_proc: FI_PageCapabilityProc,
    pub load_proc: FI_LoadProc,
    pub save_proc: FI_SaveProc,
    pub validate_proc: FI_ValidateProc,
    pub mime_proc: FI_MimeProc,
    pub supports_export_bpp_proc: FI_SupportsExportBPPProc,
    pub supports_export_type_proc: FI_SupportsExportTypeProc,
    pub supports_icc_profiles_proc: FI_SupportsICCProfilesProc,
    pub supports_no_pixels_proc: FI_SupportsNoPixelsProc,
}
#[test]
fn bindgen_test_layout_Plugin() {
    assert_eq!(
        ::std::mem::size_of::<Plugin>(),
        128usize,
        concat!("Size of: ", stringify!(Plugin))
    );
    assert_eq!(
        ::std::mem::align_of::<Plugin>(),
        8usize,
        concat!("Alignment of ", stringify!(Plugin))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).format_proc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(format_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).description_proc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(description_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).extension_proc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(extension_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).regexpr_proc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(regexpr_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).open_proc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(open_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).close_proc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(close_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).pagecount_proc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(pagecount_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).pagecapability_proc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(pagecapability_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).load_proc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(load_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).save_proc as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(save_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).validate_proc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(validate_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).mime_proc as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(mime_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).supports_export_bpp_proc as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(supports_export_bpp_proc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Plugin>())).supports_export_type_proc as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(supports_export_type_proc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Plugin>())).supports_icc_profiles_proc as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(supports_icc_profiles_proc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Plugin>())).supports_no_pixels_proc as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Plugin),
            "::",
            stringify!(supports_no_pixels_proc)
        )
    );
}
pub type FI_InitProc = ::std::option::Option<
    unsafe extern "C" fn(plugin: *mut Plugin, format_id: ::std::os::raw::c_int),
>;
extern "C" {
    pub fn FreeImage_Initialise(load_local_plugins_only: BOOL);
}
extern "C" {
    pub fn FreeImage_DeInitialise();
}
extern "C" {
    pub fn FreeImage_GetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetCopyrightMessage() -> *const ::std::os::raw::c_char;
}
pub type FreeImage_OutputMessageFunction = ::std::option::Option<
    unsafe extern "C" fn(fif: FREE_IMAGE_FORMAT, msg: *const ::std::os::raw::c_char),
>;
pub type FreeImage_OutputMessageFunctionStdCall = ::std::option::Option<
    unsafe extern "C" fn(fif: FREE_IMAGE_FORMAT, msg: *const ::std::os::raw::c_char),
>;
extern "C" {
    pub fn FreeImage_SetOutputMessageStdCall(omf: FreeImage_OutputMessageFunctionStdCall);
}
extern "C" {
    pub fn FreeImage_SetOutputMessage(omf: FreeImage_OutputMessageFunction);
}
extern "C" {
    pub fn FreeImage_OutputMessageProc(
        fif: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn FreeImage_Allocate(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_AllocateT(
        type_: FREE_IMAGE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Clone(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Unload(dib: *mut FIBITMAP);
}
extern "C" {
    pub fn FreeImage_HasPixels(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_Load(
        fif: FREE_IMAGE_FORMAT,
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_LoadU(
        fif: FREE_IMAGE_FORMAT,
        filename: *const wchar_t,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_LoadFromHandle(
        fif: FREE_IMAGE_FORMAT,
        io: *mut FreeImageIO,
        handle: fi_handle,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Save(
        fif: FREE_IMAGE_FORMAT,
        dib: *mut FIBITMAP,
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SaveU(
        fif: FREE_IMAGE_FORMAT,
        dib: *mut FIBITMAP,
        filename: *const wchar_t,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SaveToHandle(
        fif: FREE_IMAGE_FORMAT,
        dib: *mut FIBITMAP,
        io: *mut FreeImageIO,
        handle: fi_handle,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_OpenMemory(data: *mut BYTE, size_in_bytes: DWORD) -> *mut FIMEMORY;
}
extern "C" {
    pub fn FreeImage_CloseMemory(stream: *mut FIMEMORY);
}
extern "C" {
    pub fn FreeImage_LoadFromMemory(
        fif: FREE_IMAGE_FORMAT,
        stream: *mut FIMEMORY,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_SaveToMemory(
        fif: FREE_IMAGE_FORMAT,
        dib: *mut FIBITMAP,
        stream: *mut FIMEMORY,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_TellMemory(stream: *mut FIMEMORY) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn FreeImage_SeekMemory(
        stream: *mut FIMEMORY,
        offset: ::std::os::raw::c_long,
        origin: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_AcquireMemory(
        stream: *mut FIMEMORY,
        data: *mut *mut BYTE,
        size_in_bytes: *mut DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_ReadMemory(
        buffer: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        stream: *mut FIMEMORY,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_WriteMemory(
        buffer: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_uint,
        count: ::std::os::raw::c_uint,
        stream: *mut FIMEMORY,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_LoadMultiBitmapFromMemory(
        fif: FREE_IMAGE_FORMAT,
        stream: *mut FIMEMORY,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIMULTIBITMAP;
}
extern "C" {
    pub fn FreeImage_SaveMultiBitmapToMemory(
        fif: FREE_IMAGE_FORMAT,
        bitmap: *mut FIMULTIBITMAP,
        stream: *mut FIMEMORY,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_RegisterLocalPlugin(
        proc_address: FI_InitProc,
        format: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        regexpr: *const ::std::os::raw::c_char,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_RegisterExternalPlugin(
        path: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        extension: *const ::std::os::raw::c_char,
        regexpr: *const ::std::os::raw::c_char,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFIFCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_SetPluginEnabled(
        fif: FREE_IMAGE_FORMAT,
        enable: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_IsPluginEnabled(fif: FREE_IMAGE_FORMAT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_GetFIFFromFormat(format: *const ::std::os::raw::c_char) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFIFFromMime(mime: *const ::std::os::raw::c_char) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFormatFromFIF(fif: FREE_IMAGE_FORMAT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetFIFExtensionList(fif: FREE_IMAGE_FORMAT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetFIFDescription(fif: FREE_IMAGE_FORMAT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetFIFRegExpr(fif: FREE_IMAGE_FORMAT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetFIFMimeType(fif: FREE_IMAGE_FORMAT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetFIFFromFilename(
        filename: *const ::std::os::raw::c_char,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFIFFromFilenameU(filename: *const wchar_t) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_FIFSupportsReading(fif: FREE_IMAGE_FORMAT) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FIFSupportsWriting(fif: FREE_IMAGE_FORMAT) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FIFSupportsExportBPP(
        fif: FREE_IMAGE_FORMAT,
        bpp: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FIFSupportsExportType(fif: FREE_IMAGE_FORMAT, type_: FREE_IMAGE_TYPE) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FIFSupportsICCProfiles(fif: FREE_IMAGE_FORMAT) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FIFSupportsNoPixels(fif: FREE_IMAGE_FORMAT) -> BOOL;
}
extern "C" {
    pub fn FreeImage_OpenMultiBitmap(
        fif: FREE_IMAGE_FORMAT,
        filename: *const ::std::os::raw::c_char,
        create_new: BOOL,
        read_only: BOOL,
        keep_cache_in_memory: BOOL,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIMULTIBITMAP;
}
extern "C" {
    pub fn FreeImage_OpenMultiBitmapFromHandle(
        fif: FREE_IMAGE_FORMAT,
        io: *mut FreeImageIO,
        handle: fi_handle,
        flags: ::std::os::raw::c_int,
    ) -> *mut FIMULTIBITMAP;
}
extern "C" {
    pub fn FreeImage_SaveMultiBitmapToHandle(
        fif: FREE_IMAGE_FORMAT,
        bitmap: *mut FIMULTIBITMAP,
        io: *mut FreeImageIO,
        handle: fi_handle,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_CloseMultiBitmap(
        bitmap: *mut FIMULTIBITMAP,
        flags: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetPageCount(bitmap: *mut FIMULTIBITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_AppendPage(bitmap: *mut FIMULTIBITMAP, data: *mut FIBITMAP);
}
extern "C" {
    pub fn FreeImage_InsertPage(
        bitmap: *mut FIMULTIBITMAP,
        page: ::std::os::raw::c_int,
        data: *mut FIBITMAP,
    );
}
extern "C" {
    pub fn FreeImage_DeletePage(bitmap: *mut FIMULTIBITMAP, page: ::std::os::raw::c_int);
}
extern "C" {
    pub fn FreeImage_LockPage(
        bitmap: *mut FIMULTIBITMAP,
        page: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_UnlockPage(bitmap: *mut FIMULTIBITMAP, data: *mut FIBITMAP, changed: BOOL);
}
extern "C" {
    pub fn FreeImage_MovePage(
        bitmap: *mut FIMULTIBITMAP,
        target: ::std::os::raw::c_int,
        source: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetLockedPageNumbers(
        bitmap: *mut FIMULTIBITMAP,
        pages: *mut ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetFileType(
        filename: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFileTypeU(
        filename: *const wchar_t,
        size: ::std::os::raw::c_int,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFileTypeFromHandle(
        io: *mut FreeImageIO,
        handle: fi_handle,
        size: ::std::os::raw::c_int,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_GetFileTypeFromMemory(
        stream: *mut FIMEMORY,
        size: ::std::os::raw::c_int,
    ) -> FREE_IMAGE_FORMAT;
}
extern "C" {
    pub fn FreeImage_Validate(
        fif: FREE_IMAGE_FORMAT,
        filename: *const ::std::os::raw::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_ValidateU(fif: FREE_IMAGE_FORMAT, filename: *const wchar_t) -> BOOL;
}
extern "C" {
    pub fn FreeImage_ValidateFromHandle(
        fif: FREE_IMAGE_FORMAT,
        io: *mut FreeImageIO,
        handle: fi_handle,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_ValidateFromMemory(fif: FREE_IMAGE_FORMAT, stream: *mut FIMEMORY) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetImageType(dib: *mut FIBITMAP) -> FREE_IMAGE_TYPE;
}
extern "C" {
    pub fn FreeImage_IsLittleEndian() -> BOOL;
}
extern "C" {
    pub fn FreeImage_LookupX11Color(
        szColor: *const ::std::os::raw::c_char,
        nRed: *mut BYTE,
        nGreen: *mut BYTE,
        nBlue: *mut BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_LookupSVGColor(
        szColor: *const ::std::os::raw::c_char,
        nRed: *mut BYTE,
        nGreen: *mut BYTE,
        nBlue: *mut BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetBits(dib: *mut FIBITMAP) -> *mut BYTE;
}
extern "C" {
    pub fn FreeImage_GetScanLine(dib: *mut FIBITMAP, scanline: ::std::os::raw::c_int) -> *mut BYTE;
}
extern "C" {
    pub fn FreeImage_GetPixelIndex(
        dib: *mut FIBITMAP,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        value: *mut BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetPixelColor(
        dib: *mut FIBITMAP,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        value: *mut RGBQUAD,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetPixelIndex(
        dib: *mut FIBITMAP,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        value: *mut BYTE,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetPixelColor(
        dib: *mut FIBITMAP,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        value: *mut RGBQUAD,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetColorsUsed(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetBPP(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetWidth(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetHeight(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetLine(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetPitch(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetDIBSize(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetMemorySize(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetPalette(dib: *mut FIBITMAP) -> *mut RGBQUAD;
}
extern "C" {
    pub fn FreeImage_GetDotsPerMeterX(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetDotsPerMeterY(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_SetDotsPerMeterX(dib: *mut FIBITMAP, res: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn FreeImage_SetDotsPerMeterY(dib: *mut FIBITMAP, res: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn FreeImage_GetInfoHeader(dib: *mut FIBITMAP) -> *mut BITMAPINFOHEADER;
}
extern "C" {
    pub fn FreeImage_GetInfo(dib: *mut FIBITMAP) -> *mut BITMAPINFO;
}
extern "C" {
    pub fn FreeImage_GetColorType(dib: *mut FIBITMAP) -> FREE_IMAGE_COLOR_TYPE;
}
extern "C" {
    pub fn FreeImage_GetRedMask(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetGreenMask(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetBlueMask(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetTransparencyCount(dib: *mut FIBITMAP) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetTransparencyTable(dib: *mut FIBITMAP) -> *mut BYTE;
}
extern "C" {
    pub fn FreeImage_SetTransparent(dib: *mut FIBITMAP, enabled: BOOL);
}
extern "C" {
    pub fn FreeImage_SetTransparencyTable(
        dib: *mut FIBITMAP,
        table: *mut BYTE,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_IsTransparent(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTransparentIndex(dib: *mut FIBITMAP, index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn FreeImage_GetTransparentIndex(dib: *mut FIBITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_HasBackgroundColor(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetBackgroundColor(dib: *mut FIBITMAP, bkcolor: *mut RGBQUAD) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetBackgroundColor(dib: *mut FIBITMAP, bkcolor: *mut RGBQUAD) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetThumbnail(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_SetThumbnail(dib: *mut FIBITMAP, thumbnail: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetICCProfile(dib: *mut FIBITMAP) -> *mut FIICCPROFILE;
}
extern "C" {
    pub fn FreeImage_CreateICCProfile(
        dib: *mut FIBITMAP,
        data: *mut ::std::os::raw::c_void,
        size: ::std::os::raw::c_long,
    ) -> *mut FIICCPROFILE;
}
extern "C" {
    pub fn FreeImage_DestroyICCProfile(dib: *mut FIBITMAP);
}
extern "C" {
    pub fn FreeImage_ConvertLine1To4(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To4(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To4_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To4_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine24To4(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine32To4(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To8(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To8(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To8_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To8_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine24To8(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine32To8(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16_565_To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine24To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine32To16_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16_555_To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine24To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine32To16_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To24(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To24(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To24(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To24_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To24_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine32To24(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To32(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine1To32MapTransparency(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
        table: *mut BYTE,
        transparent_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To32(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine4To32MapTransparency(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
        table: *mut BYTE,
        transparent_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To32(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine8To32MapTransparency(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
        palette: *mut RGBQUAD,
        table: *mut BYTE,
        transparent_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To32_555(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine16To32_565(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertLine24To32(
        target: *mut BYTE,
        source: *mut BYTE,
        width_in_pixels: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn FreeImage_ConvertTo4Bits(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertTo8Bits(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToGreyscale(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertTo16Bits555(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertTo16Bits565(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertTo24Bits(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertTo32Bits(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ColorQuantize(
        dib: *mut FIBITMAP,
        quantize: FREE_IMAGE_QUANTIZE,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ColorQuantizeEx(
        dib: *mut FIBITMAP,
        quantize: FREE_IMAGE_QUANTIZE,
        PaletteSize: ::std::os::raw::c_int,
        ReserveSize: ::std::os::raw::c_int,
        ReservePalette: *mut RGBQUAD,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Threshold(dib: *mut FIBITMAP, T: BYTE) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Dither(dib: *mut FIBITMAP, algorithm: FREE_IMAGE_DITHER) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertFromRawBits(
        bits: *mut BYTE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_uint,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
        topdown: BOOL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertFromRawBitsEx(
        copySource: BOOL,
        bits: *mut BYTE,
        type_: FREE_IMAGE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        pitch: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_uint,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
        topdown: BOOL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToRawBits(
        bits: *mut BYTE,
        dib: *mut FIBITMAP,
        pitch: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_uint,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
        topdown: BOOL,
    );
}
extern "C" {
    pub fn FreeImage_ConvertToFloat(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToRGBF(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToRGBAF(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToUINT16(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToRGB16(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToRGBA16(dib: *mut FIBITMAP) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToStandardType(src: *mut FIBITMAP, scale_linear: BOOL)
        -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ConvertToType(
        src: *mut FIBITMAP,
        dst_type: FREE_IMAGE_TYPE,
        scale_linear: BOOL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ToneMapping(
        dib: *mut FIBITMAP,
        tmo: FREE_IMAGE_TMO,
        first_param: f64,
        second_param: f64,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_TmoDrago03(src: *mut FIBITMAP, gamma: f64, exposure: f64) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_TmoReinhard05(
        src: *mut FIBITMAP,
        intensity: f64,
        contrast: f64,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_TmoReinhard05Ex(
        src: *mut FIBITMAP,
        intensity: f64,
        contrast: f64,
        adaptation: f64,
        color_correction: f64,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_TmoFattal02(
        src: *mut FIBITMAP,
        color_saturation: f64,
        attenuation: f64,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_ZLibCompress(
        target: *mut BYTE,
        target_size: DWORD,
        source: *mut BYTE,
        source_size: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeImage_ZLibUncompress(
        target: *mut BYTE,
        target_size: DWORD,
        source: *mut BYTE,
        source_size: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeImage_ZLibGZip(
        target: *mut BYTE,
        target_size: DWORD,
        source: *mut BYTE,
        source_size: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeImage_ZLibGUnzip(
        target: *mut BYTE,
        target_size: DWORD,
        source: *mut BYTE,
        source_size: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn FreeImage_ZLibCRC32(crc: DWORD, source: *mut BYTE, source_size: DWORD) -> DWORD;
}
extern "C" {
    pub fn FreeImage_CreateTag() -> *mut FITAG;
}
extern "C" {
    pub fn FreeImage_DeleteTag(tag: *mut FITAG);
}
extern "C" {
    pub fn FreeImage_CloneTag(tag: *mut FITAG) -> *mut FITAG;
}
extern "C" {
    pub fn FreeImage_GetTagKey(tag: *mut FITAG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetTagDescription(tag: *mut FITAG) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_GetTagID(tag: *mut FITAG) -> WORD;
}
extern "C" {
    pub fn FreeImage_GetTagType(tag: *mut FITAG) -> FREE_IMAGE_MDTYPE;
}
extern "C" {
    pub fn FreeImage_GetTagCount(tag: *mut FITAG) -> DWORD;
}
extern "C" {
    pub fn FreeImage_GetTagLength(tag: *mut FITAG) -> DWORD;
}
extern "C" {
    pub fn FreeImage_GetTagValue(tag: *mut FITAG) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn FreeImage_SetTagKey(tag: *mut FITAG, key: *const ::std::os::raw::c_char) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagDescription(
        tag: *mut FITAG,
        description: *const ::std::os::raw::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagID(tag: *mut FITAG, id: WORD) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagType(tag: *mut FITAG, type_: FREE_IMAGE_MDTYPE) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagCount(tag: *mut FITAG, count: DWORD) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagLength(tag: *mut FITAG, length: DWORD) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetTagValue(tag: *mut FITAG, value: *const ::std::os::raw::c_void) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FindFirstMetadata(
        model: FREE_IMAGE_MDMODEL,
        dib: *mut FIBITMAP,
        tag: *mut *mut FITAG,
    ) -> *mut FIMETADATA;
}
extern "C" {
    pub fn FreeImage_FindNextMetadata(mdhandle: *mut FIMETADATA, tag: *mut *mut FITAG) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FindCloseMetadata(mdhandle: *mut FIMETADATA);
}
extern "C" {
    pub fn FreeImage_SetMetadata(
        model: FREE_IMAGE_MDMODEL,
        dib: *mut FIBITMAP,
        key: *const ::std::os::raw::c_char,
        tag: *mut FITAG,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetMetadata(
        model: FREE_IMAGE_MDMODEL,
        dib: *mut FIBITMAP,
        key: *const ::std::os::raw::c_char,
        tag: *mut *mut FITAG,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_SetMetadataKeyValue(
        model: FREE_IMAGE_MDMODEL,
        dib: *mut FIBITMAP,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetMetadataCount(
        model: FREE_IMAGE_MDMODEL,
        dib: *mut FIBITMAP,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_CloneMetadata(dst: *mut FIBITMAP, src: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_TagToString(
        model: FREE_IMAGE_MDMODEL,
        tag: *mut FITAG,
        Make: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FreeImage_Rotate(
        dib: *mut FIBITMAP,
        angle: f64,
        bkcolor: *const ::std::os::raw::c_void,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_RotateEx(
        dib: *mut FIBITMAP,
        angle: f64,
        x_shift: f64,
        y_shift: f64,
        x_origin: f64,
        y_origin: f64,
        use_mask: BOOL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_FlipHorizontal(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FlipVertical(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_Rescale(
        dib: *mut FIBITMAP,
        dst_width: ::std::os::raw::c_int,
        dst_height: ::std::os::raw::c_int,
        filter: FREE_IMAGE_FILTER,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_MakeThumbnail(
        dib: *mut FIBITMAP,
        max_pixel_size: ::std::os::raw::c_int,
        convert: BOOL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_RescaleRect(
        dib: *mut FIBITMAP,
        dst_width: ::std::os::raw::c_int,
        dst_height: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        filter: FREE_IMAGE_FILTER,
        flags: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_AdjustCurve(
        dib: *mut FIBITMAP,
        LUT: *mut BYTE,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_AdjustGamma(dib: *mut FIBITMAP, gamma: f64) -> BOOL;
}
extern "C" {
    pub fn FreeImage_AdjustBrightness(dib: *mut FIBITMAP, percentage: f64) -> BOOL;
}
extern "C" {
    pub fn FreeImage_AdjustContrast(dib: *mut FIBITMAP, percentage: f64) -> BOOL;
}
extern "C" {
    pub fn FreeImage_Invert(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetHistogram(
        dib: *mut FIBITMAP,
        histo: *mut DWORD,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetAdjustColorsLookupTable(
        LUT: *mut BYTE,
        brightness: f64,
        contrast: f64,
        gamma: f64,
        invert: BOOL,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FreeImage_AdjustColors(
        dib: *mut FIBITMAP,
        brightness: f64,
        contrast: f64,
        gamma: f64,
        invert: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_ApplyColorMapping(
        dib: *mut FIBITMAP,
        srccolors: *mut RGBQUAD,
        dstcolors: *mut RGBQUAD,
        count: ::std::os::raw::c_uint,
        ignore_alpha: BOOL,
        swap: BOOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_SwapColors(
        dib: *mut FIBITMAP,
        color_a: *mut RGBQUAD,
        color_b: *mut RGBQUAD,
        ignore_alpha: BOOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_ApplyPaletteIndexMapping(
        dib: *mut FIBITMAP,
        srcindices: *mut BYTE,
        dstindices: *mut BYTE,
        count: ::std::os::raw::c_uint,
        swap: BOOL,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_SwapPaletteIndices(
        dib: *mut FIBITMAP,
        index_a: *mut BYTE,
        index_b: *mut BYTE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FreeImage_GetChannel(
        dib: *mut FIBITMAP,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_SetChannel(
        dst: *mut FIBITMAP,
        src: *mut FIBITMAP,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_GetComplexChannel(
        src: *mut FIBITMAP,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_SetComplexChannel(
        dst: *mut FIBITMAP,
        src: *mut FIBITMAP,
        channel: FREE_IMAGE_COLOR_CHANNEL,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_Copy(
        dib: *mut FIBITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Paste(
        dst: *mut FIBITMAP,
        src: *mut FIBITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        alpha: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_CreateView(
        dib: *mut FIBITMAP,
        left: ::std::os::raw::c_uint,
        top: ::std::os::raw::c_uint,
        right: ::std::os::raw::c_uint,
        bottom: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_Composite(
        fg: *mut FIBITMAP,
        useFileBkg: BOOL,
        appBkColor: *mut RGBQUAD,
        bg: *mut FIBITMAP,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_PreMultiplyWithAlpha(dib: *mut FIBITMAP) -> BOOL;
}
extern "C" {
    pub fn FreeImage_FillBackground(
        dib: *mut FIBITMAP,
        color: *const ::std::os::raw::c_void,
        options: ::std::os::raw::c_int,
    ) -> BOOL;
}
extern "C" {
    pub fn FreeImage_EnlargeCanvas(
        src: *mut FIBITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        right: ::std::os::raw::c_int,
        bottom: ::std::os::raw::c_int,
        color: *const ::std::os::raw::c_void,
        options: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_AllocateEx(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        color: *const RGBQUAD,
        options: ::std::os::raw::c_int,
        palette: *const RGBQUAD,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_AllocateExT(
        type_: FREE_IMAGE_TYPE,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bpp: ::std::os::raw::c_int,
        color: *const ::std::os::raw::c_void,
        options: ::std::os::raw::c_int,
        palette: *const RGBQUAD,
        red_mask: ::std::os::raw::c_uint,
        green_mask: ::std::os::raw::c_uint,
        blue_mask: ::std::os::raw::c_uint,
    ) -> *mut FIBITMAP;
}
extern "C" {
    pub fn FreeImage_MultigridPoissonSolver(
        Laplacian: *mut FIBITMAP,
        ncycle: ::std::os::raw::c_int,
    ) -> *mut FIBITMAP;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
